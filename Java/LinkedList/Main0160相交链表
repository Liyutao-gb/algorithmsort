package linkedlist;

// 先求出lenA 和 lenB,先让较长的链表先走 |lenA - lenB| 个长度,然后在一起走找相交结点
public class Main0160相交链表 {
	public static void main(String[] args) {
		ListNode headA = new ListNode(1);
		ListNode node1 = new ListNode(2);
		ListNode headB = new ListNode(1);
		headA.next = node1;
		headB.next = node1;
		ListNode node = new Solution160().getIntersectionNode(headA, headB);
		System.out.println(node.val);
	}
}

// 判断两条单链表的最后一个节点是否相交,再求相交节点
class Solution160 {
	public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
		if (headA == null || headB == null)
			return null;

		int lenA = 1, lenB = 1;
		ListNode p, q;
		for (p = headA; p.next != null; p = p.next)
			lenA++;
		for (q = headB; q.next != null; q = q.next)
			lenB++;
		if (p != q)         // 遍历完后先判断最后一个节点是否相交
			return null;

		p = headA;
		q = headB;
		if (lenA > lenB) {
			for (int i = 0; i < lenA - lenB; i++)
				p = p.next;
		} else {
			for (int i = 0; i < lenB - lenA; i++)
				q = q.next;
		}
		while (p != q) {
			p = p.next;
			q = q.next;
		}
		return p;
	}
}
