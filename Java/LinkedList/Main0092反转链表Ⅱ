package linkedlist;

public class Main0092反转链表Ⅱ {
	public static void main(String[] args) {
		ListNode head = new ListNode(1);
		ListNode node = new ListNode(2);
		ListNode node1 = new ListNode(3);
		ListNode node2 = new ListNode(4);
		ListNode node3 = new ListNode(5);
		head.next = node;
		node.next = node1;
		node1.next = node2;
		node2.next = node3;
		ListNode between = new Solution92().reverseBetween(head, 2, 4);
		while (between != null) {
			System.out.print(between.val + " ");
			between = between.next;
		}
	}
}

// 1->2->3->4->5 from = 2, to = 4
class Solution92 {
	public ListNode reverseBetween(ListNode head, int m, int n) {
		if (head == null || head.next == null)
			return head;

		ListNode dummy = new ListNode(0);
		dummy.next = head;
		ListNode pre = dummy;
		ListNode fast = dummy;
		for (int i = 0; i < m - 1; i++)
			pre = pre.next;
		for (int i = 0; i < n; i++)
			fast = fast.next;

		ListNode slow = pre.next, tail = fast.next;
		fast.next = null;           // Key
		pre.next = reverse(slow);   // 反转指定部分链表
		slow.next = tail;           // 连接链表
		return dummy.next;
	}

	public ListNode reverse(ListNode head) {
		ListNode pre = null;
		while (head != null) {
			ListNode temp = head.next;
			head.next = pre;
			pre = head;
			head = temp;
		}
		return pre;
	}
}

// 1->2->3->4->5 from = 2, to = 4
class Solution092 {
	public ListNode reverseBetween(ListNode head, int m, int n) {
		if (head == null || head.next == null)
			return head;

		ListNode cur = head, pre = null;
		while (m > 1) {
			pre = cur;
			cur = cur.next;
			m--;
			n--;
		}
		// pre,con指向1  tail指向2
		ListNode con = pre, tail = cur;
		while (n > 0) {
			ListNode temp = cur.next;
			cur.next = con;
			con = cur;
			cur = temp;
			n--;
		}
		// pre指向1   tail指向2     con指向4      cur指向5
		if (pre != null)
			pre.next = con;     // from不为1时,用于前半段连接
		else
			head = con;         // from为1时,头结点就是con
		tail.next = cur;
		return pre;
	}
}
