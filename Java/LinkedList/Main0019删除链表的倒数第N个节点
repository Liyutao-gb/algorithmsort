package linkedlist;

//判定条件很关键,head == null || n < 1 无法返回有效值,n的有效取值范围在1 <= n <= 链表长度,
//fast走完在判定n是否大于链表长度,再进行后序操作
public class Main0019删除链表的倒数第N个节点 {
	public static void main(String[] args) {
		ListNode head = new ListNode(1);
		ListNode node1 = new ListNode(2);
		ListNode node2 = new ListNode(3);
		head.next = node1;
		node1.next = node2;
		ListNode node = new Solution19().removeNthFromEnd(head, 3);
		while (node != null) {
			System.out.print(node.val + " ");
			node = node.next;
		}
	}
}

// 新链表Operation
class Solution19 {
	public ListNode removeNthFromEnd(ListNode head, int n) {
		if (head == null || n < 1) // 不符合条件,返回原链表head
			return head;

		ListNode res = new ListNode(-1);
		res.next = head;
		ListNode slow = res; // slow和fast都指向新链表
		ListNode fast = res;
		for (int i = 0; i < n; i++) { // fast先走n步
			fast = fast.next;
		}
		if (fast == null) // 如果 fast 为null,则 n > 链表长度,返回原链表head
			return head;

		while (fast.next != null) {
			fast = fast.next;
			slow = slow.next;
		}
		slow.next = slow.next.next; // slow此时的位置在待删除节点的前一个位置
		return res.next;
	}
}

// 原链表Operation
class Solution019 {
	public ListNode removeNthFromEnd(ListNode head, int n) {
		if (head == null || n < 1)
			return head;

		ListNode cur = head;
		while (cur != null) {
			n--;
			cur = cur.next;
		}
		if (n > 0)  // n > 0 说明 n > 链表长度,返回原链表head
			return head;
		if (n == 0) // n = 0 说明待删除节点为链表的第一个结点
			return head.next;

		cur = head;
		while (n < -1) { // 如果n = 0是要删除的节点,那么n = -1 就是要删除节点的前一个节点
			n++;
			cur = cur.next;
		}
		cur.next = cur.next.next;
		return head;
	}
}

// 双向链表进行Delete DoubleNode Operation
class Solution0019 {
	public DoubleNode removeNthFromEnd(DoubleNode head, int n) {
		if (head == null || n < 1)
			return head;

		DoubleNode cur = head;
		while (cur != null) {
			n--;
			cur = cur.next;
		}
		if (n > 0)
			return head;
		if (n == 0) {
			head = head.next;   // 删除双向链表第一个节点,此时head指向第二个结点,同时head.last 指向null
			head.last = null;
			return head;
		}

		cur = head;
		while (n < -1) {
			n++;
			cur = cur.next;
		}
		DoubleNode newNext = cur.next.next; // tmp → temp.next → newNext
		cur.next = newNext;                 // 保存newNext, 让tmp.next = newNext,
		if (newNext != null) {              //判断newNext是否为null,不为null的话让newNext.last = tmp
			newNext.last = cur; 
		}
		return head;
	} 
}
